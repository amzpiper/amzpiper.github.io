(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{461:function(t,a,s){t.exports=s.p+"assets/img/Untitled.55de0a25.png"},462:function(t,a,s){t.exports=s.p+"assets/img/Untitled1.0ceb7752.png"},463:function(t,a,s){t.exports=s.p+"assets/img/Untitled2.a53c8cb7.png"},464:function(t,a,s){t.exports=s.p+"assets/img/Untitled3.4b7cd252.png"},465:function(t,a,s){t.exports=s.p+"assets/img/Untitled4.b39c1e00.png"},466:function(t,a,s){t.exports=s.p+"assets/img/Untitled5.d5830c41.png"},467:function(t,a,s){t.exports=s.p+"assets/img/Untitled6.800f720e.png"},468:function(t,a,s){t.exports=s.p+"assets/img/Untitled7.d3576971.png"},469:function(t,a,s){t.exports=s.p+"assets/img/Untitled8.e22f3b09.png"},470:function(t,a,s){t.exports=s.p+"assets/img/Untitled9.1a72d35c.png"},471:function(t,a,s){t.exports=s.p+"assets/img/Untitled10.41327893.png"},472:function(t,a,s){t.exports=s.p+"assets/img/Untitled11.9cea3283.png"},473:function(t,a,s){t.exports=s.p+"assets/img/Untitled12.9f363105.png"},474:function(t,a,s){t.exports=s.p+"assets/img/Untitled13.abbfd4db.png"},475:function(t,a,s){t.exports=s.p+"assets/img/Untitled14.95ebcc44.png"},476:function(t,a,s){t.exports=s.p+"assets/img/Untitled15.437ab5c1.png"},477:function(t,a,s){t.exports=s.p+"assets/img/Untitled16.343612b1.png"},478:function(t,a,s){t.exports=s.p+"assets/img/Untitled17.6bfad408.png"},479:function(t,a,s){t.exports=s.p+"assets/img/Untitled18.c8ec34d8.png"},480:function(t,a,s){t.exports=s.p+"assets/img/Untitled19.29809a84.png"},481:function(t,a,s){t.exports=s.p+"assets/img/Untitled20.835f763c.png"},482:function(t,a,s){t.exports=s.p+"assets/img/Untitled21.35eb6506.png"},483:function(t,a,s){t.exports=s.p+"assets/img/Untitled22.f9a2820f.png"},484:function(t,a,s){t.exports=s.p+"assets/img/Untitled23.0e239b7e.png"},485:function(t,a,s){t.exports=s.p+"assets/img/Untitled24.9390c9e1.png"},815:function(t,a,s){"use strict";s.r(a);var e=s(24),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"jvm快速入门篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm快速入门篇"}},[t._v("#")]),t._v(" JVM快速入门篇")]),t._v(" "),e("h2",{attrs:{id:"jvm探究"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm探究"}},[t._v("#")]),t._v(" JVM探究")]),t._v(" "),e("ul",[e("li",[t._v("谈谈对JVM理解？java8虚拟机和之前的变化更新？")]),t._v(" "),e("li",[t._v("什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？")]),t._v(" "),e("li",[t._v("JVM的常用调优参数？")]),t._v(" "),e("li",[t._v("内存快照如何抓取？怎么分析Dump文件？")]),t._v(" "),e("li",[t._v("谈谈JVM中，类加载器你的认识？rt-jar,ext,application")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(461),alt:"Untitled"}})]),t._v(" "),e("h2",{attrs:{id:"_1、jvm的位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、jvm的位置"}},[t._v("#")]),t._v(" 1、JVM的位置")]),t._v(" "),e("p",[t._v("在操作系统上跑的JRE软件，JRE包含JVM。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(462),alt:"Untitled"}})]),t._v(" "),e("h2",{attrs:{id:"_2、jvm的体系结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、jvm的体系结构"}},[t._v("#")]),t._v(" 2、JVM的体系结构")]),t._v(" "),e("p",[e("img",{attrs:{src:s(463),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("下面图片引用来自："),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/101495810",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/101495810"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:s(464),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("栈、本地方法栈、程序计数器一定不会有垃圾。")]),t._v(" "),e("p",[t._v("方法区属于特殊的堆，99%几乎都是在调堆。")]),t._v(" "),e("p",[t._v("Execution Engine执行引擎：JIT编译器+interpreter解释器+垃圾回收器")]),t._v(" "),e("p",[t._v("Native Method Interface-JNI Java本地接口")]),t._v(" "),e("p",[t._v("Native Method library 本地方方法库")]),t._v(" "),e("h2",{attrs:{id:"_3、类加载器-双亲委派机制-重点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、类加载器-双亲委派机制-重点"}},[t._v("#")]),t._v(" 3、类加载器&双亲委派机制（重点）")]),t._v(" "),e("p",[t._v("作用：加载class文件，比如new Student();  引用在栈里，具体的放在堆里。")]),t._v(" "),e("p",[t._v("类是抽象的，只有一个Class，对象是具体的。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(465),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("类加载器分好几个。")]),t._v(" "),e("p",[t._v("1.虚拟机自带的加载器")]),t._v(" "),e("p",[t._v("2.启动类（根）加载器")]),t._v(" "),e("p",[t._v("3.扩展类加载器")]),t._v(" "),e("p",[t._v("4.应用程序加载器或系统类加载器")]),t._v(" "),e("p",[e("strong",[t._v("双亲委派机制：保障安全")])]),t._v(" "),e("p",[t._v("APP→EXC→BOOT(最终执行)")]),t._v(" "),e("p",[t._v("往上委派，再往下委派。")]),t._v(" "),e("p",[t._v("加载步骤：")]),t._v(" "),e("p",[t._v("1.类加载器收到类加载的请求。")]),t._v(" "),e("p",[t._v("2.将这个请求向上委托给父亲加载器去完成，一直向上委托，直到启动类加载器。")]),t._v(" "),e("p",[t._v("3.启动类加载器会检查是否能够加载当前这个类，能加在就结束，使用当前加载器。")]),t._v(" "),e("p",[t._v("4.否正抛出异常Class Not Found，通知子加载器进行加载，重复步骤。")]),t._v(" "),e("p",[t._v("注意：")]),t._v(" "),e("p",[t._v("getClassLoader()报null，调用不到，因为是c写的。")]),t._v(" "),e("p",[t._v("Java = C++ 去掉繁琐的东西，指针（java可以伪造），内存管理。 = C++ - -")]),t._v(" "),e("h2",{attrs:{id:"_4、沙箱安全机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、沙箱安全机制"}},[t._v("#")]),t._v(" 4、沙箱安全机制")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   Java安全模型的核心是Java沙箱(sandbox)，什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限制在虚拟机JVM特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以一样。所有的Java程序运行都可以指定沙箱，可以定制安全策略。\n\n   在Java中将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作不受信任的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱机制。\n\n   如下图所示JDK1.0安全模型：\n")])])]),e("p",[e("img",{attrs:{src:s(466),alt:"Untitled"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   但如此严格的安全机制也给程序的功能扩展带来障碍，比如用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做出了改进，增加了`安全策略`，允许用户指定代码对本地资源的访问权限。\n")])])]),e("p",[t._v("如下图所示JDK1.1安全模型：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(467),alt:"Untitled"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   在Java1.2版本中，再次改进了安全机制，增加了`代码签名`。不论本地代码还是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化代码执行权限控制。\n\n   如下图所示JDK1.2安全模型：\n")])])]),e("p",[e("img",{attrs:{src:s(468),alt:"Untitled"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负载与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限。\n")])])]),e("p",[t._v("前")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   如下图所示JDK1.6安全模型：\n")])])]),e("p",[e("img",{attrs:{src:s(469),alt:"Untitled"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("   组成沙箱的基本组件：\n")])])]),e("ul",[e("li",[t._v("字节码校验器(bytecode verifier)：确保Java类文件遵循Java语言的规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。")]),t._v(" "),e("li",[t._v("类装载器(class loader)：其中类装载器在3个方面对Java沙箱起作用。\n"),e("ul",[e("li",[e("p",[t._v("它防止恶意代码去干涉善意代码。双亲委派机制")])]),t._v(" "),e("li",[e("p",[t._v("它守护了被信任的类库边界。")])]),t._v(" "),e("li",[e("p",[t._v("它将代码归入保护域，确定了代码可以进行哪些操作。")]),t._v(" "),e("p",[t._v("虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，他们互相之间甚至不可见。")])])])])]),t._v(" "),e("p",[t._v("类装载器采用的机制是双亲委派机制。")]),t._v(" "),e("p",[t._v("1.从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；")]),t._v(" "),e("p",[t._v("2.由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效了")]),t._v(" "),e("h2",{attrs:{id:"_5、native本地方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、native本地方法"}},[t._v("#")]),t._v(" 5、Native本地方法")]),t._v(" "),e("p",[t._v("凡是带了native关键字的方法，说明java的作用打不到了，回去调用本地方法栈，最后调用底层（JNI）C语言。")]),t._v(" "),e("p",[t._v("JNI作用：扩展Java的使用，融合不同的变成语言为Java使用！")]),t._v(" "),e("p",[t._v("在内存中专门开辟了一块标志区域：Native Method Stack，为了登记native方法，他会在执行的时候，加载本地库中的方法通过JNI。")]),t._v(" "),e("p",[t._v("如：java驱动打印机时常用native、或者使用robot类时常用。在企业级应用中很少见！")]),t._v(" "),e("p",[t._v("现在调用其他语言的方法：socket、webservice、http、rpc")]),t._v(" "),e("h2",{attrs:{id:"_6、pc寄存器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、pc寄存器"}},[t._v("#")]),t._v(" 6、PC寄存器")]),t._v(" "),e("p",[t._v("程序计数器：Program Counter Register")]),t._v(" "),e("p",[t._v("每一个线程都有一个程序计数器，是线程私有的，就是一个指针，它是指向程序方法中的方法字节码（储存指向一条指令的地址，就是即将要执行的代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。")]),t._v(" "),e("h2",{attrs:{id:"_7、方法区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、方法区"}},[t._v("#")]),t._v(" 7、方法区")]),t._v(" "),e("p",[t._v("方法区在堆内存的永久代，方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数、接口代码也在此定义，简单说，所有定义的方法的信息都保存在这里。")]),t._v(" "),e("aside",[t._v("\n💡 弹幕：方法区只是一个概念，包括了元空间和堆中的常量池、静态变量，所以说常量池在方法区中是对的。\n")]),t._v(" "),e("aside",[t._v("\n💡 **只有静态变量static、常量final、类信息Class(构造方法、接口定义)、运行时的常量池存在方法区中，实例变量存放在堆内存中，和方法区无关。**\n")]),t._v(" "),e("p",[t._v("面向对象编程-p6")]),t._v(" "),e("h2",{attrs:{id:"_8、栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、栈"}},[t._v("#")]),t._v(" 8、栈")]),t._v(" "),e("p",[t._v("是一种数据结构，是线程独享的内存区域。")]),t._v(" "),e("p",[e("strong",[t._v("特点")]),t._v("：先进后出，后进先出。- 桶")]),t._v(" "),e("p",[e("strong",[t._v("作用")]),t._v("：栈内存主管程序的运行生命周期和线程同步；")]),t._v(" "),e("p",[e("strong",[t._v("存储的内容")]),t._v("：8大基本类型（byte、char、shot、long、int、float、double、boolean）+对象引用+实例方法都在这里面。")]),t._v(" "),e("p",[t._v("一旦线程结束，栈就Over了，就释放了。不存在垃圾回收问题。")]),t._v(" "),e("p",[e("strong",[t._v("运行原理")]),t._v("：栈顶、栈底、栈帧")]),t._v(" "),e("p",[t._v("Stack2先进栈，有子帧先找子帧执行子帧Stack1。然后弹出Stack1后，回到Stack1的父帧Stack2。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(470),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("栈满了会报错StackOverflowError")]),t._v(" "),e("p",[e("strong",[t._v("栈（绿）+堆（浅蓝）+方法区（粉）+常量池（蓝）关系：")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(471),alt:"Untitled"}})]),t._v(" "),e("p",[e("strong",[t._v("任务：")])]),t._v(" "),e("p",[t._v("1.下面自己要了解一下具体的每个区是怎么存的")]),t._v(" "),e("p",[t._v("2.画一个对象实例化过程在jvm中的体现："),e("a",{attrs:{href:"https://blog.csdn.net/anying5823/article/details/107224849",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/anying5823/article/details/107224849"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_9、三种jvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、三种jvm"}},[t._v("#")]),t._v(" 9、三种JVM")]),t._v(" "),e("p",[t._v("java -version")]),t._v(" "),e("ul",[e("li",[t._v("Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)")]),t._v(" "),e("li",[t._v("Oracle JRockit 适合财务前端办公、军事指挥与控制和电信网络的需要")]),t._v(" "),e("li",[t._v("IBM J9VM")])]),t._v(" "),e("p",[t._v("我们学习的都是基于HotSpot")]),t._v(" "),e("h2",{attrs:{id:"_10、堆heap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、堆heap"}},[t._v("#")]),t._v(" 10、堆Heap")]),t._v(" "),e("p",[t._v("一个JVM只有一个堆内存，是线程共享的，而栈是线程独享级别的。堆内存的大小是可以调节的。可以通过-Xmx和-Xms控制。")]),t._v(" "),e("p",[t._v("类加载器读取了一个类文件后，一般会把什么东西放到堆中呢？类具体实例、方法、常量、变量，保存我们所有引用类型真实对象。")]),t._v(" "),e("p",[t._v("堆内存中还会细分为三个区域：")]),t._v(" "),e("ul",[e("li",[t._v("新生代（Young Generation）：满了执行轻GC\n"),e("ul",[e("li",[t._v("Eden区（存放新生对象）")]),t._v(" "),e("li",[t._v("两个幸存区（From Survivor和To Survivor）：存放每次垃圾回收后存活的对象，对象满了，会触发重GC。")])])]),t._v(" "),e("li",[t._v("老年代（Old Generation）：满了执行重GC | Full GC = Old GC+Young GC")]),t._v(" "),e("li",[t._v("永久代（Permanent Generation）：1.8以后没了，名字变为元空间")])]),t._v(" "),e("aside",[t._v("\n💡 假如堆内存满了，报OOM，java.lang.OutOfMemoryError:java heap space\n")]),t._v(" "),e("h2",{attrs:{id:"_11、新生代-老年代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、新生代-老年代"}},[t._v("#")]),t._v(" 11、新生代&老年代")]),t._v(" "),e("ul",[e("li",[t._v("对象：诞生、成长、甚至死亡的地方。")]),t._v(" "),e("li",[t._v("伊甸园区：所有的对象都是在这里new出来的。满了执行轻Minor GC，如果经过1次GC后会进入到幸存区。有的对象依旧存在引用时会活下来，移到幸存区中。")]),t._v(" "),e("li",[t._v("两个幸存区：当这里的对象满了，会将所有对象移动到老年代中。老年代也满了，触发Full GC,当这些对象都不会被回收时，触发OOM。")])]),t._v(" "),e("p",[t._v("真相：经过研究99%的对象都是临时对象！")]),t._v(" "),e("h2",{attrs:{id:"_12、永久代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12、永久代"}},[t._v("#")]),t._v(" 12、永久代")]),t._v(" "),e("p",[t._v("方法区（被所有线程共享）在这里，这个区域时常驻内存的。用来存放JDK自身携带的class对象。接口元数据，存储java运行时的环境。这个区域不存在垃圾回收。当关闭虚拟机时就会释放这个区域内存。")]),t._v(" "),e("ul",[e("li",[t._v("jdk1.6之前：永久代，常量池在方法区中。")]),t._v(" "),e("li",[t._v("jdk1.7：永久代，慢慢的退化了，提出去永久代，常量池在堆中。")]),t._v(" "),e("li",[t._v("jdk1.8之后：无永久代，变为元空间，常量池在元空间。")])]),t._v(" "),e("aside",[t._v("\n💡 什么情况下永久代会崩溃：当一个启动类加载了大量的第三方jar包；tomcat部署了大量的应用；大量动态生产的反射类，不断的被加载\n")]),t._v(" "),e("p",[e("strong",[t._v("结构：")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(472),alt:"Untitled"}})]),t._v(" "),e("p",[e("img",{attrs:{src:s(473),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("永久代也叫非堆。")]),t._v(" "),e("h2",{attrs:{id:"_13、堆内存调优"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13、堆内存调优"}},[t._v("#")]),t._v(" 13、堆内存调优")]),t._v(" "),e("p",[t._v("可以通过-Xmx和-Xms控制。")]),t._v(" "),e("p",[t._v("-Xmx:初始化内存分配大小")]),t._v(" "),e("p",[t._v("-Xms:最大分配内存")]),t._v(" "),e("p",[t._v("-XX:+PrintGCDetails：查看GC垃圾回收信息")]),t._v(" "),e("p",[t._v("-XX:+HeapDumpOnOutOfMemoryError：生成OutOfMemoryError错误后的dump信息")]),t._v(" "),e("p",[e("strong",[t._v("测试一：-Xms1024m -Xmx1024m -XX:+PrintGCDetails")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(474),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("运行结果：计算新生代+老年代内存=总内存，发现元空间在物理上不存在，逻辑上存在。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(475),alt:"Untitled"}})]),t._v(" "),e("p",[e("strong",[t._v("测试二：-Xms8m -Xmx8m -XX:+PrintGCDetails")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(476),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("运行结果：走轻GC、重GC，最后报OOM，但不清楚为什么出现OOM，需要检查")]),t._v(" "),e("p",[e("img",{attrs:{src:s(477),alt:"Untitled"}})]),t._v(" "),e("aside",[t._v("\n💡 **OOM：解决办法？**\n1.尝试扩大堆内存，看结果。不报错了就是内存分配不够。\n2.假如还报错，就是因为代码问题，分析内存，看哪个地方出现了问题（专业工具jprofiler）\n      2.1.最快解决办法：看出代码问题：使用内存快照分析工具，MAT(eclipse)，jprofiler\n      2.2.Dubug，一行行分析代码。\n3.MAT(eclipse)，jprofiler作用：\n      3.1.分析dump文件，快速定位内存泄露；\n      3.2.获取堆中数据；\n      3.3.获取大的对象；\n")]),t._v(" "),e("p",[t._v("教程："),e("a",{attrs:{href:"https://blog.csdn.net/vicky_pyh/article/details/88797514",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://blog.csdn.net/vicky_pyh/article/details/88797514"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("下载exe地址："),e("a",{attrs:{href:"https://www.ej-technologies.com/download/jprofiler/version_92",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.ej-technologies.com/download/jprofiler/version_92"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_14、使用jprofiler工具分析oom原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14、使用jprofiler工具分析oom原因"}},[t._v("#")]),t._v(" 14、使用jprofiler工具分析OOM原因")]),t._v(" "),e("p",[t._v("测试代码：")]),t._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[t._v("package io"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("renren"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("test"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" java"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("util"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ArrayList"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" class Demo03 {\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// m")]),t._v("\n    byte"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" array "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new byte"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" static void main"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" {\n        ArrayList"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Demo03"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new ArrayList"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<>")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//oom 一般都是死循环")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" {\n            list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new Demo03"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            count"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        }\n    }\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br")])]),e("p",[t._v("设置命令：Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError，用来生产dump文件")]),t._v(" "),e("p",[t._v("运行后生成文件。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(478),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("打开文件，查看类：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(479),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("查看最大对象：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(480),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("查看线程转储，查看main线程，分析代码出错行：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(481),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("结束后记得删除文件夹：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(482),alt:"Untitled"}})]),t._v(" "),e("h2",{attrs:{id:"_15、gc垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15、gc垃圾回收"}},[t._v("#")]),t._v(" 15、GC垃圾回收")]),t._v(" "),e("p",[t._v("自动回收，只能在堆和方法区(在堆中)中起作用。")]),t._v(" "),e("p",[t._v("JVM在GC时，并不是对3个区域统一回收，大部分GC都是在新生代。")]),t._v(" "),e("ul",[e("li",[t._v("新生代（minor轻GC）\n"),e("ul",[e("li",[t._v("伊甸园区")]),t._v(" "),e("li",[t._v("幸存区（from、to）")])])]),t._v(" "),e("li",[t._v("老年代（full重GC）")]),t._v(" "),e("li",[t._v("元空间")])]),t._v(" "),e("p",[t._v("GC有两种：minor轻GC、full重GC")]),t._v(" "),e("p",[t._v("题目：")]),t._v(" "),e("p",[t._v("1.JVM的内存模型和分区~详细到每个区放什么？")]),t._v(" "),e("p",[t._v("2.堆里面分区有哪些？edan，from，to，老年区，说说特点？")]),t._v(" "),e("p",[t._v("3.GC的算法有哪些？它们之间的特点？怎么用？原理？")]),t._v(" "),e("p",[t._v("标记清楚、标记压缩/整理、复制算法、引用计数法")]),t._v(" "),e("p",[t._v("4.轻GC和重GC分别在什么时候发生？")]),t._v(" "),e("h3",{attrs:{id:"_15-1、引用计数法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-1、引用计数法"}},[t._v("#")]),t._v(" 15.1、引用计数法")]),t._v(" "),e("p",[t._v("对象被引用就加1，给每个对象配一个计数器，计数器本身有消耗。假如有死循环后无解。引用为0时被GC清楚。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(483),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("不高效。")]),t._v(" "),e("p",[t._v("可达性分析+引用计数法来判断对象是否存活。")]),t._v(" "),e("h3",{attrs:{id:"_15-2、复制算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-2、复制算法"}},[t._v("#")]),t._v(" 15.2、复制算法")]),t._v(" "),e("p",[t._v("1.每次GC都会将Edan区存活的对象移到幸存区中，一旦被GC后，Edan区变为空。")]),t._v(" "),e("p",[t._v("2.复制算法用来把其中一个幸存区的数据移动到另一个，来保证每次GC都存在一个空的幸存区to。")]),t._v(" "),e("p",[t._v("新生区有幸存区to和from，需要分辨出谁是to，to是指向，谁空谁是to。")]),t._v(" "),e("p",[t._v("当一个对象经理15次GC后依旧存活，会移动到老年代。这个次数可以调节，命令参数为")]),t._v(" "),e("p",[t._v("-XX:MaxTenuringThreshold=5")]),t._v(" "),e("h3",{attrs:{id:"_15-3、标记清除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-3、标记清除"}},[t._v("#")]),t._v(" 15.3、标记清除")]),t._v(" "),e("p",[t._v("解决复制算法需要额外空间的问题，时间换空间。")]),t._v(" "),e("p",[t._v("扫描对象，对活得对象进行标记；")]),t._v(" "),e("p",[t._v("扫描对象，对没有标记的对象进行清除；")]),t._v(" "),e("p",[e("img",{attrs:{src:s(484),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("缺点：回收时需要扫描2次，浪费时间，清除后产生内存碎片。")]),t._v(" "),e("p",[t._v("优点：不需要复制算法的额外空间。")]),t._v(" "),e("h3",{attrs:{id:"_15-4、标记压缩-整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-4、标记压缩-整理"}},[t._v("#")]),t._v(" 15.4、标记压缩/整理")]),t._v(" "),e("p",[t._v("优化标记清除的问题，增加第三次扫描，压缩，防止内存碎片。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(485),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("先标记清除几次，再标记压缩。")]),t._v(" "),e("h3",{attrs:{id:"_15-5、总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-5、总结"}},[t._v("#")]),t._v(" 15.5、总结")]),t._v(" "),e("p",[t._v("内存效率 (时间复杂度)：复制算法>标记清楚算法>标记压缩算法\n内存整齐率：复制算法=标记压缩算法>标记清楚算法")]),t._v(" "),e("p",[t._v("内存利用率：标记压缩算法=标记清楚算法>复制算法")]),t._v(" "),e("p",[t._v("没有最优算法。只有最合适的算法，GC是分代收集算法。")]),t._v(" "),e("p",[t._v("新生代：每次GC时有大量对象死亡，存活率低，用复制算法，只需要付出少量的复制成本！")]),t._v(" "),e("p",[t._v("老年代：存活率很高，区域大，没有额外空间进行处理，使用标记清除+标记压缩混合使用。多少次清除后再压缩。")]),t._v(" "),e("h2",{attrs:{id:"_16、java-memory-modle-内存模型-jmm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16、java-memory-modle-内存模型-jmm"}},[t._v("#")]),t._v(" 16、Java Memory Modle-内存模型（JMM）")]),t._v(" "),e("h3",{attrs:{id:"_16-1-jmm是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-jmm是什么"}},[t._v("#")]),t._v(" 16.1.JMM是什么？")]),t._v(" "),e("p",[t._v("百度百科")]),t._v(" "),e("p",[t._v("内存模型")]),t._v(" "),e("h3",{attrs:{id:"_16-2-是来干嘛的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-2-是来干嘛的"}},[t._v("#")]),t._v(" 16.2.是来干嘛的？")]),t._v(" "),e("p",[t._v("找官网，看别人的博客，视频。")]),t._v(" "),e("p",[t._v("解决主内存与线程的工作内存一致性问题。")]),t._v(" "),e("p",[t._v("定义了java虚拟机在计算机内存中的工作方式，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与"),e("a",{attrs:{href:"https://www.zhihu.com/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A29881777%7D",target:"_blank",rel:"noopener noreferrer"}},[t._v("计算机内存"),e("OutboundLink")],1),t._v("是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。")]),t._v(" "),e("h3",{attrs:{id:"_16-3-如何学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-3-如何学习"}},[t._v("#")]),t._v(" 16.3.如何学习？")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/null-qige/p/9481900.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/null-qige/p/9481900.html"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）")]),t._v(" "),e("ul",[e("li",[t._v("lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态")]),t._v(" "),e("li",[t._v("unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定")]),t._v(" "),e("li",[t._v("read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用")]),t._v(" "),e("li",[t._v("load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中")]),t._v(" "),e("li",[t._v("use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令")]),t._v(" "),e("li",[t._v("assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中")]),t._v(" "),e("li",[t._v("store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用")]),t._v(" "),e("li",[t._v("write　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中")])]),t._v(" "),e("p",[t._v("JMM对这八种指令的使用，制定了如下规则：")]),t._v(" "),e("ul",[e("li",[t._v("不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write")]),t._v(" "),e("li",[t._v("不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存")]),t._v(" "),e("li",[t._v("不允许一个线程将没有assign的数据从工作内存同步回主内存")]),t._v(" "),e("li",[t._v("一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作")]),t._v(" "),e("li",[t._v("一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁")]),t._v(" "),e("li",[t._v("如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值")]),t._v(" "),e("li",[t._v("如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量")]),t._v(" "),e("li",[t._v("对一个变量进行unlock操作之前，必须把此变量同步回主内存")])]),t._v(" "),e("p",[t._v("JMM对这八种操作规则和对"),e("a",{attrs:{href:"https://www.cnblogs.com/null-qige/p/8569131.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("volatile的一些特殊规则"),e("OutboundLink")],1),t._v("就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。")]),t._v(" "),e("p",[t._v("引用："),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29881777",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/29881777"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("学习volatile:"),e("a",{attrs:{href:"https://www.cnblogs.com/null-qige/p/8569131.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/null-qige/p/8569131.html"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("JUC与高并发："),e("a",{attrs:{href:"https://segmentfault.com/a/1190000037680416",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000037680416"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("面试题："),e("a",{attrs:{href:"http://blog.itpub.net/69917606/viewspace-2644603/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://blog.itpub.net/69917606/viewspace-2644603/"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_17、总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17、总结"}},[t._v("#")]),t._v(" 17、总结")]),t._v(" "),e("p",[t._v("针对面试学习和针对技术学习")]),t._v(" "),e("p",[t._v("分析面试没答上来的题-触类旁通，通过大量的面试总结，总结一套解题思路。")]),t._v(" "),e("p",[t._v("1.不懂的百度")]),t._v(" "),e("p",[t._v("2.做思维导图")])])}),[],!1,null,null,null);a.default=v.exports}}]);