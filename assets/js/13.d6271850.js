(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{746:function(t,s,n){t.exports=n.p+"assets/img/Untitled.628f7240.png"},747:function(t,s,n){t.exports=n.p+"assets/img/Untitled1.73238418.png"},748:function(t,s,n){t.exports=n.p+"assets/img/Untitled2.f932a64d.png"},749:function(t,s,n){t.exports=n.p+"assets/img/Untitled3.dcc1e08f.png"},750:function(t,s,n){t.exports=n.p+"assets/img/Untitled4.b55f2104.png"},751:function(t,s,n){t.exports=n.p+"assets/img/Untitled5.71d7ec72.png"},752:function(t,s,n){t.exports=n.p+"assets/img/Untitled6.54c06adc.png"},753:function(t,s,n){t.exports=n.p+"assets/img/Untitled7.6a4ccc28.png"},836:function(t,s,n){"use strict";n.r(s);var a=n(24),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),a("h2",{attrs:{id:"设计模式的六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的六大原则"}},[t._v("#")]),t._v(" "),a("strong",[t._v("设计模式的六大原则:")])]),t._v(" "),a("p",[t._v("设计模式的世界丰富多彩，比如生产一个个「产品」的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等。")]),t._v(" "),a("p",[t._v("面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。设计模式对于程序员而言并不陌生，每个程序员在编程时都会或多或少地接触到设计模式。无论是在大型程序的架构中，亦或是在源码的学习中，设计模式都扮演着非常重要的角色。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("开闭原则")]),t._v("：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。")]),t._v(" "),a("li",[a("strong",[t._v("单一职责原则")]),t._v("：一个类只做一件事，一个类应该只有一个引起它修改的原因。")]),t._v(" "),a("li",[a("strong",[t._v("里氏替换原则")]),t._v("：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。")]),t._v(" "),a("li",[a("strong",[t._v("依赖倒置原则")]),t._v("：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。")]),t._v(" "),a("li",[a("strong",[t._v("迪米特法则")]),t._v("：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。")]),t._v(" "),a("li",[a("strong",[t._v("接口隔离原则")]),t._v("：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。")])]),t._v(" "),a("h2",{attrs:{id:"_5-种构建型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-种构建型模式"}},[t._v("#")]),t._v(" 5 种构建型模式：")]),t._v(" "),a("h3",{attrs:{id:"一、单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、单例模式"}},[t._v("#")]),t._v(" 一、单例模式")]),t._v(" "),a("p",[t._v("单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(746),alt:"Untitled"}})]),t._v(" "),a("p",[a("strong",[t._v("问题：")])]),t._v(" "),a("p",[t._v("单例模式同时解决了两个问题， 所以违反了_单一职责原则_：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("保证一个类只有一个实例")]),t._v("。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。")]),t._v(" "),a("p",[t._v("它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。")]),t._v(" "),a("p",[t._v("注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它"),a("strong",[t._v("必须")]),t._v("总是返回一个新对象。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("为该实例提供一个全局访问节点")]),t._v("。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。")]),t._v(" "),a("p",[t._v("和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。")]),t._v(" "),a("p",[t._v("还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。")])])]),t._v(" "),a("p",[a("strong",[t._v("解决方案：")])]),t._v(" "),a("p",[t._v("所有单例的实现都包含以下两个相同的步骤：")]),t._v(" "),a("ul",[a("li",[t._v("将默认构造函数设为私有， 防止其他对象使用单例类的 "),a("code",[t._v("new")]),t._v("运算符。")]),t._v(" "),a("li",[t._v("新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。")])]),t._v(" "),a("p",[a("strong",[t._v("单例模式结构：")])]),t._v(" "),a("p",[a("img",{attrs:{src:n(747),alt:"Untitled1"}})]),t._v(" "),a("p",[t._v("单例 （Singleton） 类声明了一个名为 "),a("code",[t._v("get­Instance")]),t._v("获取实例的静态方法来返回其所属类的一个相同实例。单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 "),a("code",[t._v("获取实例")]),t._v("方法必须是获取单例对象的唯一方式。")]),t._v(" "),a("p",[a("strong",[t._v("例子：")])]),t._v(" "),a("p",[t._v("Java标准库有一些类就是单例，例如Runtime这个类：")]),t._v(" "),a("p",[a("code",[t._v("Runtime runtime = Runtime.getRuntime();")])]),t._v(" "),a("p",[t._v("有些童鞋可能听说过延迟加载，即在调用方第一次调用"),a("code",[t._v("getInstance()")]),t._v("时才初始化全局唯一实例，类似这样：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tprivatestatic "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" INSTANCE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\n\t\tpublicstatic "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INSTANCE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t    INSTANCE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" INSTANCE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br")])]),a("p",[t._v("这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：加锁会严重影响并发性能。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INSTANCE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        INSTANCE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" INSTANCE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。")]),t._v(" "),a("p",[t._v("另一种实现Singleton的方式是利用Java的"),a("code",[t._v("enum")]),t._v("，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("World")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 唯一枚举:")]),t._v("\n\t\t\tINSTANCE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"world"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\treturnthis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t\n\t\tpublicvoid "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("p",[t._v("什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是new操作符：")]),t._v(" "),a("p",[a("strong",[t._v("适合应用场景：")])]),t._v(" "),a("p",[t._v("1.如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。")]),t._v(" "),a("p",[t._v("单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。")]),t._v(" "),a("p",[t._v("2.如果你需要更加严格地控制全局变量， 可以使用单例模式。")]),t._v(" "),a("p",[t._v("单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。")]),t._v(" "),a("p",[a("strong",[t._v("优点：")])]),t._v(" "),a("ul",[a("li",[t._v("你可以保证一个类只有一个实例。")]),t._v(" "),a("li",[t._v("你获得了一个指向该实例的全局访问节点。")]),t._v(" "),a("li",[t._v("仅在首次请求单例对象时对其进行初始化。")])]),t._v(" "),a("p",[a("strong",[t._v("缺点：")])]),t._v(" "),a("ul",[a("li",[t._v("违反了_单一职责原则_。 该模式同时解决了两个问题。")]),t._v(" "),a("li",[t._v("单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。")]),t._v(" "),a("li",[t._v("该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。")]),t._v(" "),a("li",[t._v("单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。")])]),t._v(" "),a("p",[a("strong",[t._v("与其他模式的关系：")])]),t._v(" "),a("ul",[a("li",[t._v("**"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"}},[t._v("外观模式"),a("OutboundLink")],1),a("strong",[t._v("类通常可以转换为")]),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[t._v("单例模式"),a("OutboundLink")],1),t._v("**类， 因为在大部分情况下一个外观对象就足够了。")]),t._v(" "),a("li",[t._v("如果你能将对象的所有共享状态简化为一个享元对象， 那么**"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/flyweight",target:"_blank",rel:"noopener noreferrer"}},[t._v("享元模式"),a("OutboundLink")],1),a("strong",[t._v("就和")]),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[t._v("单例"),a("OutboundLink")],1),t._v("**类似了。 但这两个模式有两个根本性的不同。\n"),a("ol",[a("li",[t._v("只会有一个单例实体， 但是"),a("em",[t._v("享元")]),t._v("类可以有多个实体， 各实体的内在状态也可以不同。")]),t._v(" "),a("li",[a("em",[t._v("单例")]),t._v("对象可以是可变的。 享元对象是不可变的。")])])]),t._v(" "),a("li",[a("strong",[a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象工厂模式"),a("OutboundLink")],1)]),t._v("、 **"),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"}},[t._v("生成器模式"),a("OutboundLink")],1),a("strong",[t._v("和")]),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"}},[t._v("原型模式"),a("OutboundLink")],1),a("strong",[t._v("都可以用")]),a("a",{attrs:{href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"}},[t._v("单例"),a("OutboundLink")],1),t._v("**来实现。")])]),t._v(" "),a("h3",{attrs:{id:"二、工厂方法模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、工厂方法模式"}},[t._v("#")]),t._v(" 二、工厂方法模式")]),t._v(" "),a("p",[t._v("工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(748),alt:"Untitled2"}})]),t._v(" "),a("p",[a("strong",[t._v("问题：")])]),t._v(" "),a("p",[t._v("假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 "),a("code",[t._v("卡车")]),t._v("的类中。")]),t._v(" "),a("p",[t._v("一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(749),alt:"Untitled3"}})]),t._v(" "),a("p",[t._v("如果代码其余部分与现有类已经存在耦合关系， 那么向程序中添加新类其实并没有那么容易。")]),t._v(" "),a("p",[t._v("这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 "),a("code",[t._v("卡车")]),t._v("类相关。 在程序中添加 "),a("code",[t._v("轮船")]),t._v("类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。")]),t._v(" "),a("p",[t._v("最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。")]),t._v(" "),a("p",[a("strong",[t._v("解决方案：")])]),t._v(" "),a("p",[t._v("工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(750),alt:"Untitled4"}})]),t._v(" "),a("p",[t._v("子类可以修改工厂方法返回的对象类型。")]),t._v(" "),a("p",[t._v("乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。")]),t._v(" "),a("p",[t._v("但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(751),alt:"Untitled5"}})]),t._v(" "),a("p",[t._v("所有产品都必须使用同一接口。")]),t._v(" "),a("p",[t._v("举例来说，  卡车Truck和 轮船Ship类都必须实现 运输Transport接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  陆路运输Road­Logistics类中的工厂方法返回卡车对象， 而 海路运输Sea­Logistics类则返回轮船对象。")]),t._v(" "),a("p",[a("img",{attrs:{src:n(752),alt:"Untitled6"}})]),t._v(" "),a("p",[t._v("只要产品类实现一个共同的接口， 你就可以将其对象传递给客户代码， 而无需提供额外数据。")]),t._v(" "),a("p",[t._v("调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。")]),t._v(" "),a("p",[a("strong",[t._v("工厂方法模式结构:")])]),t._v(" "),a("p",[a("img",{attrs:{src:n(753),alt:"Untitled7"}})]),t._v(" "),a("p",[a("strong",[t._v("例子：")])]),t._v(" "),a("p",[t._v("工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("┌─────────────┐      ┌─────────────┐\n│   Product   │      │   Factory   │\n└─────────────┘      └─────────────┘\n       ▲                    ▲\n       │                    │\n┌─────────────┐      ┌─────────────┐\n│ ProductImpl │<─ ─ ─│ FactoryImpl │\n└─────────────┘      └─────────────┘\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("我们以具体的例子来说：假设我们希望实现一个解析字符串到"),a("code",[t._v("Number")]),t._v("的"),a("code",[t._v("Factory")]),t._v("，可以定义如下：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("publicinterfaceNumberFactory {\n    Number parse(String s);\n}\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("有了工厂接口，再编写一个工厂的实现类：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("publicclassNumberFactoryImplimplementsNumberFactory {public Number parse(String s) {\nreturnnew BigDecimal(s);\n    }\n}\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("而产品接口是"),a("code",[t._v("Number")]),t._v("，"),a("code",[t._v("NumberFactoryImpl")]),t._v("返回的实际产品是"),a("code",[t._v("BigDecimal")]),t._v("。")]),t._v(" "),a("p",[t._v("那么客户端如何创建"),a("code",[t._v("NumberFactoryImpl")]),t._v("呢？通常我们会在接口"),a("code",[t._v("Factory")]),t._v("中定义一个静态方法"),a("code",[t._v("getFactory()")]),t._v("来返回真正的子类：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("publicinterfaceNumberFactory {// 创建方法:\n    Number parse(String s);\n\n// 获取工厂实例:static NumberFactory getFactory() {\nreturn impl;\n    }\n\nstatic NumberFactory impl =new NumberFactoryImpl();\n}\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("在客户端中，我们只需要和工厂接口"),a("code",[t._v("NumberFactory")]),t._v("以及抽象产品"),a("code",[t._v("Number")]),t._v("打交道：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('NumberFactory factory = NumberFactory.getFactory();\nNumber result = factory.parse("123.456");\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("调用方可以完全忽略真正的工厂"),a("code",[t._v("NumberFactoryImpl")]),t._v("和实际的产品"),a("code",[t._v("BigDecimal")]),t._v("，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。")]),t._v(" "),a("p",[t._v("有的童鞋会问：一个简单的"),a("code",[t._v("parse()")]),t._v("需要写这么复杂的工厂吗？实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：")]),t._v(" "),a("p",[t._v("有的童鞋会问：一个简单的"),a("code",[t._v("parse()")]),t._v("需要写这么复杂的工厂吗？实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("publicclassNumberFactory {publicstatic Number parse(String s) {\nreturnnew BigDecimal(s);\n    }\n}\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Integer n = Integer.valueOf(100);\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[a("code",[t._v("Integer")]),t._v("既是产品又是静态工厂。它提供了静态方法"),a("code",[t._v("valueOf()")]),t._v("来创建"),a("code",[t._v("Integer")]),t._v("。那么这种方式和直接写"),a("code",[t._v("new Integer(100)")]),t._v("有何区别呢？我们观察"),a("code",[t._v("valueOf()")]),t._v("方法：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("publicfinalclassInteger {publicstatic Integer valueOf(int i) {\nif (i >= IntegerCache.low && i <= IntegerCache.high)\nreturn IntegerCache.cache[i + (-IntegerCache.low)];\nreturnnew Integer(i);\n    }\n    ...\n}\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("它的好处在于，"),a("code",[t._v("valueOf()")]),t._v("内部可能会使用"),a("code",[t._v("new")]),t._v("创建一个新的"),a("code",[t._v("Integer")]),t._v("实例，但也可能直接返回一个缓存的"),a("code",[t._v("Integer")]),t._v("实例。对于调用方来说，没必要知道"),a("code",[t._v("Integer")]),t._v("创建的细节。")]),t._v(" "),a("blockquote",[a("p",[t._v("工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。")])]),t._v(" "),a("p",[t._v("如果调用方直接使用"),a("code",[t._v("Integer n = new Integer(100)")]),t._v("，那么就失去了使用缓存优化的可能性。")]),t._v(" "),a("p",[t._v("我们经常使用的另一个静态工厂方法是"),a("code",[t._v("List.of()")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('List<String> list = List.of("A", "B", "C");\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("这个静态工厂方法接收可变参数，然后返回"),a("code",[t._v("List")]),t._v("接口。需要注意的是，调用方获取的产品总是"),a("code",[t._v("List")]),t._v("接口，而且并不关心它的实际类型。即使调用方知道"),a("code",[t._v("List")]),t._v("产品的实际类型是"),a("code",[t._v("java.util.ImmutableCollections$ListN")]),t._v("，也不要去强制转型为子类，因为静态工厂方法"),a("code",[t._v("List.of()")]),t._v("保证返回"),a("code",[t._v("List")]),t._v("，但也完全可以修改为返回"),a("code",[t._v("java.util.ArrayList")]),t._v("。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。")]),t._v(" "),a("p",[t._v("总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。")]),t._v(" "),a("p",[t._v("和"),a("code",[t._v("List.of()")]),t._v("类似，我们使用"),a("code",[t._v("MessageDigest")]),t._v("时，为了创建某个摘要算法，总是使用静态工厂方法"),a("code",[t._v("getInstance(String)")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('MessageDigest md5 = MessageDigest.getInstance("MD5");\nMessageDigest sha1 = MessageDigest.getInstance("SHA-1");\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是"),a("code",[t._v("MessageDigest")]),t._v("这个抽象类。")]),t._v(" "),a("h2",{attrs:{id:"_7-种结构型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-种结构型模式"}},[t._v("#")]),t._v(" 7 种结构型模式：")]),t._v(" "),a("h2",{attrs:{id:"_11-种行为型模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-种行为型模式"}},[t._v("#")]),t._v(" 11 种行为型模式：")])])}),[],!1,null,null,null);s.default=e.exports}}]);